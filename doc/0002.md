Here's a complete guide for TypeORM column types:

**String Types:**
```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn("uuid")
  declare id: string;

  // short text — names, titles
  @Column({ type: "varchar", length: 100 })
  declare firstName: string;

  // longer text — descriptions, bios
  @Column({ type: "text" })
  declare bio: string;

  // fixed length — country codes, status codes
  @Column({ type: "char", length: 2 })
  declare countryCode: string;
}
```

**Number Types:**
```typescript
@Entity()
export class Product {
  @PrimaryGeneratedColumn()
  declare id: number;

  // whole numbers — age, quantity, count
  @Column({ type: "int" })
  declare age: number;

  // large whole numbers — big counts
  @Column({ type: "bigint" })
  declare views: number;

  // small whole numbers — ratings 1-5
  @Column({ type: "smallint" })
  declare rating: number;

  // decimal — price, weight (precision=total digits, scale=decimal places)
  @Column({ type: "decimal", precision: 10, scale: 2 })
  declare price: number;

  // floating point — coordinates, measurements
  @Column({ type: "float" })
  declare latitude: number;
}
```

**Boolean:**
```typescript
@Entity()
export class User {
  // true/false — flags, toggles
  @Column({ type: "boolean", default: false })
  declare isVerified: boolean;

  @Column({ type: "boolean", default: true })
  declare isActive: boolean;
}
```

**Date Types:**
```typescript
@Entity()
export class User {
  // auto set on create
  @CreateDateColumn()
  declare createdAt: Date;

  // auto set on create and update
  @UpdateDateColumn()
  declare updatedAt: Date;

  // auto set on delete (soft delete)
  @DeleteDateColumn()
  declare deletedAt: Date;

  // manual date — birthdate, expiry
  @Column({ type: "date" })
  declare birthDate: Date;

  // date with time
  @Column({ type: "timestamp" })
  declare scheduledAt: Date;
}
```

**JSON Types:**
```typescript
@Entity()
export class User {
  // storing objects — settings, metadata, preferences
  @Column({ type: "jsonb" }) // jsonb for postgres (indexed, faster)
  declare preferences: Record<string, unknown>;

  @Column({ type: "json" }) // json for mysql
  declare metadata: Record<string, unknown>;
}
```

**Enum Types:**
```typescript
// define enum
export enum UserRole {
  ADMIN = "admin",
  USER = "user",
  MODERATOR = "moderator",
}

export enum OrderStatus {
  PENDING = "pending",
  PROCESSING = "processing",
  SHIPPED = "shipped",
  DELIVERED = "delivered",
  CANCELLED = "cancelled",
}

@Entity()
export class User {
  @Column({ type: "enum", enum: UserRole, default: UserRole.USER })
  declare role: UserRole;
}

@Entity()
export class Order {
  @Column({ type: "enum", enum: OrderStatus, default: OrderStatus.PENDING })
  declare status: OrderStatus;
}
```

**Nullable and Default:**
```typescript
@Entity()
export class User {
  // nullable — optional fields
  @Column({ type: "varchar", length: 255, nullable: true })
  declare avatar: string | null;

  // default value
  @Column({ type: "int", default: 0 })
  declare points: number;

  // unique — emails, usernames
  @Column({ type: "varchar", length: 255, unique: true })
  declare email: string;
}
```

**Real World User Entity combining everything:**
```typescript
// entities/user.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
} from "typeorm";

export enum UserRole {
  ADMIN = "admin",
  USER = "user",
  MODERATOR = "moderator",
}

@Entity("users")
export class User {
  @PrimaryGeneratedColumn("uuid")
  declare id: string;

  @Column({ type: "varchar", length: 100 })
  declare firstName: string;

  @Column({ type: "varchar", length: 100 })
  declare lastName: string;

  @Column({ type: "varchar", length: 255, unique: true })
  declare email: string;

  @Column({ type: "text" })
  declare password: string;

  @Column({ type: "text" })
  declare salt: string;

  @Column({ type: "varchar", length: 255, nullable: true })
  declare avatar: string | null;

  @Column({ type: "enum", enum: UserRole, default: UserRole.USER })
  declare role: UserRole;

  @Column({ type: "boolean", default: false })
  declare isVerified: boolean;

  @Column({ type: "boolean", default: true })
  declare isActive: boolean;

  @Column({ type: "int", default: 0 })
  declare points: number;

  @Column({ type: "jsonb", nullable: true })
  declare preferences: Record<string, unknown> | null;

  @Column({ type: "date", nullable: true })
  declare birthDate: Date | null;

  @CreateDateColumn()
  declare createdAt: Date;

  @UpdateDateColumn()
  declare updatedAt: Date;

  @DeleteDateColumn()
  declare deletedAt: Date | null;
}
```

**Quick reference for when to use what:**

| Type | Use For |
|------|---------|
| `varchar` | names, emails, titles |
| `text` | bio, description, password hash |
| `char` | country codes, fixed codes |
| `int` | age, quantity, count |
| `bigint` | views, large counts |
| `decimal` | price, money |
| `float` | coordinates, measurements |
| `boolean` | flags, toggles |
| `date` | birthdate, expiry |
| `timestamp` | scheduled time, events |
| `jsonb` | settings, metadata (postgres) |
| `json` | settings, metadata (mysql) |
| `enum` | roles, status, categories |

---
TypeORM provides several ways to add indexes:

**Single Column Index:**
```typescript
import { Entity, Column, Index } from "typeorm";

@Entity("users")
export class User {
  // index on single column
  @Index()
  @Column({ type: "varchar", length: 255, unique: true })
  declare email: string;

  // unique index
  @Index({ unique: true })
  @Column({ type: "varchar", length: 100 })
  declare username: string;
}
```

**Composite Index (multiple columns):**
```typescript
// on top of class
@Entity("users")
@Index(["firstName", "lastName"]) // composite index
@Index(["email", "isActive"])     // another composite index
export class User {
  @Column({ type: "varchar", length: 100 })
  declare firstName: string;

  @Column({ type: "varchar", length: 100 })
  declare lastName: string;

  @Column({ type: "boolean", default: true })
  declare isActive: boolean;
}
```

**Named Index:**
```typescript
@Entity("users")
@Index("IDX_USER_EMAIL_ACTIVE", ["email", "isActive"])
export class User {
  @Column({ type: "varchar", length: 255 })
  declare email: string;

  @Column({ type: "boolean", default: true })
  declare isActive: boolean;
}
```

**Full Text Search Index (postgres):**
```typescript
@Entity("products")
@Index(["name", "description"], { fulltext: true })
export class Product {
  @Column({ type: "varchar", length: 255 })
  declare name: string;

  @Column({ type: "text" })
  declare description: string;
}
```

**Spatial Index:**
```typescript
@Entity("locations")
export class Location {
  @Index({ spatial: true })
  @Column({ type: "geometry", spatialFeatureType: "Point", srid: 4326 })
  declare coordinates: string;
}
```

**Real World Example combining everything:**
```typescript
// entities/user.entity.ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  Index,
} from "typeorm";

export enum UserRole {
  ADMIN = "admin",
  USER = "user",
  MODERATOR = "moderator",
}

@Entity("users")
@Index("IDX_USER_FULLNAME", ["firstName", "lastName"])        // search by full name
@Index("IDX_USER_EMAIL_ACTIVE", ["email", "isActive"])        // filter active users by email
@Index("IDX_USER_ROLE_ACTIVE", ["role", "isActive"])          // filter active users by role
export class User {
  @PrimaryGeneratedColumn("uuid")
  declare id: string;

  @Column({ type: "varchar", length: 100 })
  declare firstName: string;

  @Column({ type: "varchar", length: 100 })
  declare lastName: string;

  // unique index — most queried column
  @Index({ unique: true })
  @Column({ type: "varchar", length: 255, unique: true })
  declare email: string;

  @Column({ type: "text" })
  declare password: string;

  @Column({ type: "text" })
  declare salt: string;

  @Column({ type: "varchar", length: 255, nullable: true })
  declare avatar: string | null;

  // index — frequently filtered
  @Index()
  @Column({ type: "enum", enum: UserRole, default: UserRole.USER })
  declare role: UserRole;

  // index — frequently filtered
  @Index()
  @Column({ type: "boolean", default: false })
  declare isVerified: boolean;

  @Column({ type: "boolean", default: true })
  declare isActive: boolean;

  @Column({ type: "int", default: 0 })
  declare points: number;

  @Column({ type: "jsonb", nullable: true })
  declare preferences: Record<string, unknown> | null;

  @Column({ type: "date", nullable: true })
  declare birthDate: Date | null;

  // index — frequently sorted
  @Index()
  @CreateDateColumn()
  declare createdAt: Date;

  @UpdateDateColumn()
  declare updatedAt: Date;

  @DeleteDateColumn()
  declare deletedAt: Date | null;
}
```

**When to add indexes — quick rule:**

| Scenario | Add Index |
|----------|-----------|
| Column used in `WHERE` clause | ✅ Yes |
| Column used in `ORDER BY` | ✅ Yes |
| Column used in `JOIN` | ✅ Yes |
| Foreign keys | ✅ Always |
| Unique fields like email | ✅ Always |
| Columns rarely queried | ❌ No |
| Boolean columns alone | ❌ Low cardinality, not worth it |
| `jsonb` whole column | ❌ Index specific jsonb fields instead |

**Key rules to remember:**

- Indexes **speed up reads** but **slow down writes** — don't over-index
- **High cardinality** columns benefit most from indexes — `email`, `id`, `createdAt`
- **Low cardinality** columns like `boolean` alone are not worth indexing
- **Composite indexes** follow left-to-right rule — `["email", "isActive"]` helps queries on `email` alone but not `isActive` alone
- **Foreign keys** should always be indexed as they are used in joins constantly